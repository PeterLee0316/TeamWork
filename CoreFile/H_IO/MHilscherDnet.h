/* Generated by Together */
/* written by jsMoon on 2004.03.17 */

#ifndef MHILSCHERDNET_H
#define MHILSCHERDNET_H
#include "IIO.h"
#include "CIFUSER.h"

#ifdef VIRTUAL_DEVICE_IO
#import "Server.tlb" no_namespace
#endif

#define INPUT_ORIGIN		1000
#define OUTPUT_ORIGIN		2000
#define OUTPUT_END			3000

// #define SUCCESS		0
#define ERROR_ID	-1

#define TRUE		1
#define FALSE		0

const BYTE highbitsMask[8] =
	{
		0x00,  //0000 0000
		0x01,  //0000 0001
		0x03,  //0000 0011
		0x07,  //0000 0111
		0x0F,  //0000 1111
		0x1F,  //0001 1111
		0x3F,  //0011 1111
		0x7F,  //0111 1111
		
	};

const BYTE lowbitsMask[8] =
	{
		0xFE,  //1111 1110
		0xFC,  //1111 1100
		0xF8,  //1111 1000
		0xF0,  //1111 0000
		0xE0,  //1110 0000
		0xC0,  //1100 0000
		0x80,  //1000 0000
		0x00,  //0000 0000
	};

typedef

 /**
  * Devicenet의 Master와 Slave의 상태를 Devicenet 모듈로 부터 읽어오기 위한 데이타 구조체이다. 
  */
 struct DNM_DIAGNOSTICStag {
  /** bit field to show network and DEVICE main errors */
  struct  GLOBAL_BITS {
    unsigned char bCtrl     : 1; /* wrong parameterization                  */
    unsigned char bAClr     : 1; /* auto_clear activated                    */
    unsigned char bNonExch  : 1; /* no data exchange to at least on station */
    unsigned char bFatal    : 1; /* fatal error occured                     */
    unsigned char bEvent    : 1; /* bus error events occured                */
    unsigned char bNRdy     : 1; /* host program not ready                  */
    unsigned char bDupMAC   : 1; /* duplicate MAC id detected check failed  */
    unsigned char bPerDup   : 1; /* duplicate MAC Id check active           */
  } bGlobalBits;

  /** global state for the different DEVICE main states */
  unsigned char   bDNM_state;
  #define OFFLINE  0x00
  #define STOP     0x40
  #define CLEAR    0x80
  #define OPERATE  0xC0

  /** location of error and error code */
  struct T_ERRORS
  {
    unsigned char bErrDevAdr; /* 0-63, 255 */
    #define MST_ERR  0xFF

    unsigned char bErrEvent;   /* see #defines */

    /* DEVICE internal errors */

    #define TASK_F_UNKNOWN_MODE                     52 /* unknown handshake mode configured */
    #define TASK_F_BAUDRATE_OUT_RANGE               53 /* configured batudrate not supported */
    #define TASK_F_OWN_MAC_ID_OUT_RANGE             54 /* DEVICE MAC-ID out of range */
    #define TASK_F_DUPLICATE_MAC_ID                 57 /* a duplicate MAC-ID detected */
    #define TASK_F_NO_DEV_TAB                       58 /* data base in the DEVICE has no entries included */
    #define TASK_F_ADR_DOUBLE                       59 /* double MAC-ID configured internally */
    #define TASK_F_DATA_SET_FIELD_LEN               60 /* size of one device data set invalid */
    #define TASK_F_PRED_MST_SL_ADD_LEN              61 /* offset table for predef.mst slave conn. invalid */
    #define TASK_F_PRED_MSTSL_CFG_FIELD_LEN         62 /* configur. table length for predef.mst.slave conn. invalid */
    #define TASK_F_PRED_MST_SL_ADD_TAB_INCONS       63 /* offset table do not correspond to I/O configuration table */
    #define TASK_F_EXPL_PRM_FIELD_LEN               64 /* size indicator of parameter data table corrupt */
    #define TASK_F_PRED_MSTSL_CFG_ADD_INPUT_INCONS  65 /* num of inputs in add tab not equal I/O configuration */
    #define TASK_F_PRED_MSTSL_CFG_ADD_OUTPUT_INCONS 66 /* num of outputs in add tab not equal I/O configuration */
    #define TASK_F_UNKNOWN_DATA_TYPE                67 /* unknown data type in I/O configuration */
    #define TASK_F_MODULE_DATA_SIZE                 68 /* data type does not correspond to its configured length */
    #define TASK_F_OUTPUT_OFF_RANGE                 69 /* configured output offset address out of range */
    #define TASK_F_INPUT_OFF_RANGE                  70 /* configured input offset address out of */
    #define TASK_F_WRONG_TYPE_OF_CONNECTION         71 /* one predefined connection type is unknown */
    #define TASK_F_TYPE_CONNECTION_REDEFINITION     72 /* multiple connections defined in parallel */
    #define TASK_F_EXP_PACKET_LESS_PROD_INHIBIT     73 /* configured EXP_PCKT_RATE less then PROD_INHIBIT_TIME */
    #define TASK_F_PRM_FIELD_LEN_INCONSISTENT       74 /* parameter field DNM_SET_ATTR_DATA in data set inconsitent */
    #define TASK_F_NO_CAN                           75 /* no device responding on CAN network at cfg.baudrate */
    #define TASK_F_REG_FRAG_TIMEOUT_OUT_OF_RANGE    76 /* usRegFragTimeout out of range */

  } tError;

  /** counter for the bus error events */
  unsigned short  usBus_Error_Cnt;

  /** counter of bus off reports of the CAN chip */
  unsigned short  usBus_Off_Cnt;

  /** reserved area */
  struct SVR_STATUS
  {
    unsigned char bSrvExpl   : 1; /* server explicit connection established */
    unsigned char bSrvIO     : 1; /* server I/O poll connection established */
    unsigned char bReserved  : 6; /* reserved bits */
  } bSrvStatus;
  #define SRV_EXPL 0x01
  #define SRV_IO   0x02

  unsigned char   abReserved[7];

  /* Bit-Ready, Cfg-Ready and diagnostic display of the devices */
  /** device configuration area */
  unsigned char   abDv_cfg  [16];  /* device configuration area */
  /** device state information area */
  unsigned char   abDv_state[16];  /* device state information area */
  /** device diagnostic area */
  unsigned char   abDv_diag [16];  /* device diagnostic area */

} DNM_DIAGNOSTICS;


class MHilscherDnet : public IIO {

	/** Error Base */
	int	m_iErrorBase;

	// Object ID
	int m_iObjectID;	

	/** MAttachAcf Log File Handler */
	MLog	*m_plogMng;

    /** Board number (0..3)   */
    unsigned short m_usBoardNumber;

    /**
     * Device가 Open 되었는지를 확인하는 Flag : m_BDeviceOpened = TRUE if it is opened; m_BDeviceOpened = FALSE if it is not opened.
     */
    BOOL m_BDeviceOpened;

    /** I/O Device의 status가 Update되는 배열 */
    BYTE m_ucOutgoingBuffer[MAX_DEVICE * 4];

    /** I/O Device에 적용될 Digital Command를 담고있는 배열 */
	BYTE m_ucIncomingBuffer[MAX_DEVICE * 4];

	/* Device의 상태 정보를 저장한 영역 */
	DN_STATUS	m_tblDnStatus;

public:

	/** Default Constructor  
	 * @stereotype constructor
	 */
	MHilscherDnet();

	/** Standard Constructor  
	 * @stereotype constructor
	 * @param iObjectID : Component의 Object ID
	 * @param iErrorBase : Error 시작 Offset
	 * @param strFullFileName : 로그 파일 이름 및 Path
	 * @param ucLevel : 로그 수준
						DEF_MLOG_NONE_LOG_LEVEL    : 0x00;	// Log 안 함
						DEF_MLOG_ERROR_LOG_LEVEL   : 0x01;	// Error관련 Log
						DEF_MLOG_WARNING_LOG_LEVEL : 0x02;	// Warning 관련 Log
						DEF_MLOG_NORMAL_LOG_LEVEL  : 0x04;	// 정상 동작 관련 Log
	  * @param iDays : 로그 파일 보관 기간
	  * @param usBoardNumber : Board Number
	 */
	MHilscherDnet(
		int				iObjectID, 
		int				iErrorBase, 
		CString			strFullFileName, 
		BYTE			ucLevel, 
		int				iDays = 30, 
		unsigned short	usBoardNumber = 0
	);

     /** 보급형 Contructor 
     * MHILSCHERDNET 객체생성자로써 Board Number를 parameter로 받는다.
     * @param usBoardNumber : Board Number
     * @return 0 = Success, 그외 = Error Number
	 * @stereotype constructor
     */
	MHilscherDnet(unsigned short usBoardNumber);

	/** @stereotype Destructor */
	virtual ~MHilscherDnet();

	// 아래 함수들은 IIO Class에 선언 되어 있으며 상세한 설명은 IIO.h를 참조하세요.
    /**
     * Hilscher Board와의 Communication을 위한 Driver를 Open하며, Board를 초기화하고 통신 대기 상태가 되게 한다.
     * @return 0 = Success, 그외 = Error Number
     */
    int Initialize();

    /**
     * I/O Device의 Digital Status (Bit) 를  읽어드린다.
     * @precondition 이 함수를 실행하기 전에 initialize 함수가 미리 실행되었어야 한다.
     * @param usIOAddr : IO Address
	 * @param pbVal    : IO 값
     * @return  0      : SUCCESS
	            else   : Device \Error 코드 
     */
	int GetBit(unsigned short usIOAddr, BOOL *pbval);

    /**
     * Hilscher Board와의 Communication을 종료하고 Device Driver를 Close한다.
     * @return 0 = Success, 그외 = Error Number
     */
    int Terminate();

    /**
     * I/O Device의 Digital Status (Bit) 를 읽어들여 bit 값을 아규먼트로 리턴한다.
     * @precondition 이 함수를 실행하기 전에 initialize 함수가 미리 실행되었어야 한다.
     * @param usIOAddr : IO Address
	 * @param pbVal    : TRUE : 값이 1 임, FALSE : 값이 0 임
     * @return  0      : SUCCESS
	            else   : Device Error 코드 
     */
   int IsOn(unsigned short usIOAddr, BOOL *pbVal);

   /**
     * I/O Device의 Digital Status (Bit) 를 읽어들여 bit 값을 아규먼트로 리턴한다.
     * @precondition 이 함수를 실행하기 전에 initialize 함수가 미리 실행되었어야 한다.
     * @param usIOAddr : IO Address
	 * @param pbVal    : TRUE : 값이 0 임, FALSE : 값이 1 임
     * @return  0      : SUCCESS
	            else   : Device Error 코드 
     */
	int IsOff(unsigned short usIOAddr, BOOL *pbVal);

    /**
     * Output Device에 On Command (Bit = 1) 를 보낸다.
     * @param usIOAddr : IO Address
     * @return 0 = Success, 그외 = Error Number
     */
    int OutputOn(unsigned short usIOAddr);

    /**
     * Output Device에 Off Command (Bit = 0) 를 보낸다.
     * @param usIOAddr : IO Address
     * @return 0 = Success, 그외 = Error Number
     */
    int OutputOff(unsigned short usIOAddr);

    /**
     * Output Device의 Digital Status가 Set이면 (Bit = 0), Output Device에 On Command (Bit = 1) 를 보내고,
     * Output Device의 Digital Status가 Clear이면 (Bit = 1), Output Device에 Off Command (Bit = 0) 를 보낸다.
     * @param usIOAddr : IO Address
     * @return 0 = Success, 그외 = Error Number
     */
    int OutputToggle(unsigned short usIOAddr);

    /**
     * 연속된 8개의 IO Address로 구성된 Input Device 들의 Digital Status를 읽어들여 pcValue pointer에 넘겨준다.
     * @param usIOAddr : 연속된 8개의 IO Address를 시작하는 IO Address
     * @param pcValuse : 연속된 8개의 IO Address로 구성된 Input Device 들의 Digital Status를 읽어들여 pcValue에 저장한다.
     * @return 0 = Success, 그외 = Error Number
     */
    int GetByte(unsigned short usIOAddr, BYTE & pcValue);

    /**
     * 연속된 8개의 IO Address로 구성된 Output Device들에 On or Off Command를 보낸다.
     * @param usIOAddr : 연속된 8개의 IO Address를 시작하는 IO Address
     * @param pcValuse : Output Device에 보낼 Command를 저장하고 있는 변수이다.
     * @return 0 = Success, 그외 = Error Number
     */
    int PutByte(unsigned short usIOAddr, BYTE pcValue);

    /**
     * 연속된 16개의 IO Address로 구성된 Input Device 들의 Digital Status를 읽어들여 pcValue pointer에 넘겨준다.
     * @param usIOAddr : 연속된 16개의 IO Address를 시작하는 IO Address
     * @param pwValuse : 연속된 16개의 IO Address로 구성된 Input Device 들의 Digital Status를 읽어들여 pcValue에 저장한다.
     * @return 0 = Success, 그외 = Error Number
     */
    int GetWord(unsigned short usIOAddr, WORD & pwValue);

    /**
     * 연속된 16개의 IO Address로 구성된 Output Device들에 On or Off Command를 보낸다.
     * @param usIOAddr : 연속된 16개의 IO Address를 시작하는 IO Address
     * @param pwValuse : Output Device에 보낼 Command를 저장하고 있는 변수이다.
     * @return 0 = Success, 그외 = Error Number
     */
    int PutWord(unsigned short usIOAddr, WORD pwValue);

    /**
     * I/O Device의 Digital Status (Bit) 를  읽어드린다.
     * @precondition 이 함수를 실행하기 전에 initialize 함수가 미리 실행되었어야 한다.
     * @param strIOAddr : IO Address String (ex, "1000:START_SW")
	 * @param pbVal    : IO 값
     * @return  0      : SUCCESS
	            else   : Device \Error 코드 
     */
    int GetBit(CString strIOAddr, BOOL *pbVal);

    /**
     * I/O Device의 Digital Status (Bit) 를 읽어들여 Bit = 1이면, TRUE(1)를 Return하고, Bit = 0이면 FALSE(0)를 Return한다.
     * @precondition 이 함수를 실행하기 전에 initialize 함수가 미리 실행되었어야 한다.
     * @param strIOAddr : IO Address String (ex, "1000:START_SW")
	 * @param pbVal    : IO 값
     * @return  0      : SUCCESS
	            else   : Device \Error 코드 
     */
    int IsOn(CString strIOAddr, BOOL *pbVal);

    /**
     * Output Device에 On Command (Bit = 1) 를 보낸다.
     * @param strIOAddr : IO Address String (ex, "1000:START_SW")
     * @return 0 = Success, 그외 = Error Number
     */
    int OutputOn(CString strIOAddr);

    /**
     * Output Device에 Off Command (Bit = 0) 를 보낸다.
     * @param strIOAddr : IO Address String (ex, "1000:START_SW")
     * @return 0 = Success, 그외 = Error Number
     */
    int OutputOff(CString strIOAddr);

    /**
     * Output Device의 Digital Status가 Set이면 (Bit = 0), Output Device에 On Command (Bit = 1) 를 보내고,
     * Output Device의 Digital Status가 Clear이면 (Bit = 1), Output Device에 Off Command (Bit = 0) 를 보낸다.
     * @param strIOAddr : IO Address String (ex, "1000:START_SW")
     * @return 0 = Success, 그외 = Error Number
     */
    int OutputToggle(CString strIOAddr);

    /**
     * 연속된 8개의 IO Address로 구성된 Input Device 들의 Digital Status를 읽어들여 pcValue pointer에 넘겨준다.
     * @param strIOAddr : 연속된 8개의 IO Address를 시작하는 IO Address의 String Type (ex, "1000:START_SW")
     * @param pcValuse : 연속된 8개의 IO Address로 구성된 Input Device 들의 Digital Status를 읽어들여 pcValue에 저장한다.
     * @return 0 = Success, 그외 = Error Number
     */
    int GetByte(CString strIOAddr, BYTE & pcValue);

    /**
     * 연속된 8개의 IO Address로 구성된 Output Device들에 On or Off Command를 보낸다.
     * @param strIOAddr : 연속된 8개의 IO Address를 시작하는 IO Address의 String Type (ex, "1000:START_SW")
     * @param pcValuse : Output Device에 보낼 Command를 저장하고 있는 변수이다.
     * @return 0 = Success, 그외 = Error Number
     */
    int PutByte(CString strIOAddr, BYTE pcValue);

    /**
     * 연속된 16개의 IO Address로 구성된 Input Device 들의 Digital Status를 읽어들여 pcValue pointer에 넘겨준다.
     * @param strIOAddr : 연속된 16개의 IO Address를 시작하는 IO Address의 String Type (ex, "1000:START_SW")
     * @param pwValuse : 연속된 16개의 IO Address로 구성된 Input Device 들의 Digital Status를 읽어들여 pcValue에 저장한다.
     * @return 0 = Success, 그외 = Error Number
     */
    int GetWord(CString strIOAddr, WORD & pwValue);

    /**
     * 연속된 16개의 IO Address로 구성된 Output Device들에 On or Off Command를 보낸다.
     * @param strIOAddr : 연속된 16개의 IO Address를 시작하는 IO Address의 String Type (ex, "1000:START_SW")
     * @param pwValuse : Output Device에 보낼 Command를 저장하고 있는 변수이다.
     * @return 0 = Success, 그외 = Error Number
     */
    int PutWord(CString strIOAddr, WORD pwValue);

	/**
     * Incoming Buffer를 Update하고, Outgoing Buffer의 내용을 Physical I/O에 적용하는 IOThread를 Run한다.
     */
    void RunIOThread();

	/**
	 * Master 모듈 및 Slave 모듈 상태 정보를 얻어온다.
	 *
	 * @param  DnStatus : 마스터와 64개의 Slave에 대한 상태 정보 구조체
	 * @return 0		= 모두 정상
			   others	= 하나라도 실패
	 */
	int DnStatusGet(DN_STATUS DnStatus);

private:
	/**
     * String Type I/O Address를 unsigned short type으로 전환 하여 usIOAddr에 I/O Address를 return.
	 * @param strIOAddr : String Type I/O Address (ex, "1000:START_SW")
	 * @param usIOAddr : unsigned short type I/O Address
     * @return 0 = Success, 그외 = Error Number
     */
    int IOAddrInterpreter(CString strIOAddr, unsigned short & usIOAddr);

	/**
     * Thread로써 InputData[]를 Update하고, OutputData[]를 Physical I/O에 적용한다.
     */	
	UINT IOThread(LPVOID lParam);

	static DWORD WINAPI EntryPoint(LPVOID pParam);

	/**
	 * Master 모듈 및 Slave 모듈 상태 체크
	 *
	 * @param ubMacID : 대상 Slave Mac Address
              -1      : 모든 Slave 체크 (Default)
	 * @return 0		= SUCCESS
			   others	= ERROR Code
	 */
	int dnStatusCheck(unsigned char ucMacID = 0xff);

	/**
	 * Master 모듈 및 Slave 모듈 상태 체크
	 *
	 * @return 0		= SUCCESS
			   others	= ERROR Code
	 */
	int returnDnetStatus();
    
   /**************** Common Interface ************************************/
public :

   /**
     * Error Code Base를 설정한다. 
	 *
	 * @param	iErrorBase : (OPTION=0) 설정할 Error Base 값
     */
    virtual void SetErrorBase(int iErrorBase = 0);

    /**
     * Error Code Base를 읽는다. 
	 *
	 * @return	int : Error Base 값
     */
    virtual int GetErrorBase(void) const;


   /**
     * Object ID를 설정한다. 
	 *
	 * @param	iObjectID : 설정할 Object ID 값
     */
    virtual void SetObjectID(int iObjectID);

    /**
     * Object ID를 읽는다. 
	 *
	 * @return	int : Object ID 값
     */
    virtual int GetObjectID(void);
	
	/** 
	 * Log Class의 개체 Pointer를 설정한다.
	 *
	 * @param		*pLogObj: 연결할 Log Class의 개체 Pointer
	 * @return		Error Code : 0 = Success, 그 외 = Error
	 */
	virtual int SetLogObject(MLog *pLogObj);

   /**
     * Log File과 관련된 attribute를 지정한다.
     *
	 * @param	iObjectID : ObjectID
     * @param	strFileName : file path 및 file name을 가지는 string
     * @param	ucLevel : log level 지정 bitwise 정보
     * @param	iDays : (OPTION=30) 현재 set되어 있는 log file 저장일
     * @return	Error Code : 0 = Success, 그 외 = Error
     */
    virtual int SetLogAttribute (int iObjectID, CString strFullFileName, BYTE ucLevel, int iDays = 30);
    /**
     * 오래된 Log file을 삭제한다.
     *
     * @return	Error Code : 0 = Success, 그 외 = Error
     */

    virtual int DeleteOldLogFiles (void);

	/** 
	 * Log manager를 반환한다.
	 *
	 * @return	MLog* : 반환할 Log Manager Pointer
	 */
	virtual MLog* GetLogManager();	


	/** 
	 * Component의 Error Code Base를 반환한다.
	 *
	 * @param		Error Code: ObjectID + Error Base 
	 * @return		ErrorBase가 제거된 Component Error Code 
	 */
	int DecodeError(int iErrCode);

/*----------- Component 공통 Private Method Start -------*/

private:
	/**
	 * Error Code 생성하기
	 *  +-----------+-------------------------+
	 *  | Object ID | Error Code + Error Base |
	 *  | (2 bytes) |        (2 bytes)        |
	 *  +-----------+-------------------------+
	 *
	 * @param	iErrCode : 발생한 Error Code
	 * @return	Error Code : Object ID (2bytes)와 Error Code + Error Base (2bytes)를 4bytes로 조합한 코드
	 */
	int generateErrorCode(int iErrCode);

#ifdef VIRTUAL_DEVICE_IO
	void VirtualIOExchange();
	void ShowMessage(_com_error &e);
	IVirtualDeviceNetPtr m_compDNet;
	IVirtualDeviceNet	*m_compIIOBus;
#endif
};

#endif //MHILSCHERDNET_H
